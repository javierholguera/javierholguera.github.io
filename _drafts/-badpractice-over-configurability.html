---
layout: post
title: "[BadPractice] Over configurability"
date: 
type: post
published: false
status: draft
categories:
- Software Practices
tags:
- bad
- badpractice
- cheatsheet
- practice
meta:
  _edit_last: '1'
author:
  login: admin
  email: javier.holguera@gmail.com
  display_name: admin
  first_name: ''
  last_name: ''
---
<p>The description that we got for this practice in the Clean Code Cheat Sheet is:</p>
<blockquote><p>Prevent configuration just for the sake of it – or because nobody can decide<br />
how it should be. Otherwise, this will result in overly complex, unstable<br />
systems</p></blockquote>
<p>Let’s analyse these two reasons.</p>
<h3>Configuring for the sake of it</h3>
<p>It can happen when we don’t pounder correctly how likely is that, for the value that we want to configure, to change and how costly it would be if it actually changed. For example, until 2008 Spain had a pretty stable VAT value (16%) for most of its products. We may argue that a value that is unlikely to change shouldn’t be defined in a configurable format, for instance a web.config or a database value.</p>
<p>However a couple of years after this value changed a couple of times, so we could have thought that the value was now volatile enough so we need to configure it.</p>
<p>Nevertheless, I would not make this value configurable for a couple of reasons:</p>
<ul>
<li>It’s not going to change from one machine or environment to the other, no matters if we are in production or development.</li>
<li>If we chose to define it as an app setting or similar in the web/app.config, we amount of effort that we would need to update it compared to hard-coding it in a single DLL and updating that DLL, would be similar.</li>
<li>If we prefer to define it in the database, we may end up with tables where there are thousands of entries of business values that “may” change. Most of them won’t change ever, but we will have to deal with the fact that these values are very frequently used across the system, so some caching mechanism will be required to avoid performance being hit.</li>
</ul>
<p>Therefore, I would chose to define it in code but in just ONE place, a well-known placed where all the other bits in the system can make use of it. If we are developing based on some kind of “domain-driven” style, then the election is pretty obvious.</p>
<p>Another reason that is similar to this one would be the typical reasoning behind most YAGNI (You Aren’t Gonna Need It): just in case…</p>
<h3>Nobody can decide how it should be</h3>
<p>This is definitively worse than the previous point, because it’s a clear indication that the organization or the business layer has some kind of business paralysis, incapable to taking decisions. That is going to affect the system and, in general, the team productivity more than any bad practice or design decision.</p>
<h3>A third reason: inertia</h3>
<p>A third reason not mentioned in the Cheat Sheet description is just inertia, or “we always did it in this way”. Personally I have suffered this with Dependency Injection containers.</p>
<p>A couple years ago, when XML was “the big thing” and everything should be done using it, most DI containers offer a way to configure dependencies and their resolution in web/app.config files, using some XML vocabulary. The theory said that it was a good idea to use this XML-based configuration for a couple of reasons:</p>
<ul>
<li>It was “readable”, if you can call those big chunks of XML like that.</li>
<li>It was possible to change behaviour without recompiling any assembly (some that personally I have never done).</li>
<li>It was handy for testing, because you could reconfigure your dependency resolution to use different classes in testing projects.</li>
</ul>
<p>Some time later, containers started to offer programmatic interfaces, or at least they became more popular. They offer almost the same benefits of XML-based configuration, without some of their hassle:</p>
<ul>
<li>They were even more readable, because code was easier to read than XML.</li>
<li>It was possible to register different behaviours for testing, replacing production registrations on demand, even on a test-to-test basis.</li>
<li>It was possible to scaffolding the configuration across different classes and different levels of abstraction.</li>
</ul>
<p>However, the definitive benefit was the fact that XML was error-prone and definition/spelling errors where spotted in runtime only.</p>
<p>All in all, it seemed to be clear that programmatic registration was a better choice than XML-based one, but it took me and my colleagues a couple of months to stop doing what we were used to, reflect on it and change our minds. Sad that we went through unnecessary pain, but a valuable lesson to learn from the future.</p>
<h3>Conclusion</h3>
<p>To sum up, configuration should be kept to a minimum, as a necessary evil that will add complexity to your system and you should use when it’s absolutely required.</p>
