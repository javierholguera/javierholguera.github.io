---
layout: post
title: "[GoodPractice] Prefer polymorphism to if/else or switch/case"
date: 
type: post
published: false
status: draft
categories:
- Software Practices
tags:
- cleancode
- good
- goodpractice
- practice
meta:
  _edit_last: '1'
author:
  login: admin
  email: javier.holguera@gmail.com
  display_name: admin
  first_name: ''
  last_name: ''
---
<p>This is one of the practices that are referenced in the Clean Code Cheat Sheet, in this case under the Design category. The description for the practice is:</p>
<blockquote><p>“ONE SWITCH”: There may be no more than one switch statement for a given type of selection. The cases in that switch statement must create polymorphic objects that take the place of other such switch statements in the rest of the system.</p></blockquote>
<p>What does it mean? In my opinion it means that, for a class hierarchy of set of objects that represent a similar concept, the code should be able to handle them homogeneously, while the differences between them would be implemented directly in the subclasses themselves.</p>
<h3>A good example</h3>
<p>For instance, if we take the classic "geometric figures” example, we know that there would be some kind of abstraction that represents all of them and their functionality, be it an interface or an abstract class.</p>
<p><a href="http://javi.azurewebsites.net/wp-content/uploads/2014/03/image.png"><img style="display: inline; background-image: none;" title="image" alt="image" src="{{ site.baseurl }}/assets/image_thumb.png" width="579" height="308" border="0" /></a></p>
<p>The implementations of this abstraction would deal with the particularities of each implementation, while they would be transparent for the rest of the system. Among other benefits, it would be easier to maintain and extend and would follow different principles of software development, like Open/Closed Principle (OCP).</p>
<h3>A bad example</h3>
<p>The reverse of the previous example would be a design where different classes would be responsible for dealing with the differences, in terms of functionality, of rectangles, circles, squares, etc.</p>
<pre class="csharpcode"><span class="kwrd">switch</span> (figure.Type)
{
    <span class="kwrd">case</span> FigureType.Circle:
        <span class="rem">// do stuff</span>
        <span class="kwrd">break</span>;

    <span class="kwrd">case</span> FigureType.Square:
        <span class="rem">// do different stuff</span>
        <span class="kwrd">break</span>;

    <span class="kwrd">case</span> FigureType.Rectangle
        <span class="rem">// do another stuff</span>
        <span class="kwrd">break</span>;

    <span class="kwrd">default</span>:
        <span class="rem">// fail spectacularly</span>
        <span class="kwrd">break</span>;
}</pre>
<style type="text/css"><!--<br />
.csharpcode, .csharpcode pre<br />
{<br />
	font-size: small;<br />
	color: black;<br />
	font-family: consolas, "Courier New", courier, monospace;<br />
	background-color: #ffffff;<br />
	/*white-space: pre;*/<br />
}<br />
.csharpcode pre { margin: 0em; }<br />
.csharpcode .rem { color: #008000; }<br />
.csharpcode .kwrd { color: #0000ff; }<br />
.csharpcode .str { color: #006080; }<br />
.csharpcode .op { color: #0000c0; }<br />
.csharpcode .preproc { color: #cc6633; }<br />
.csharpcode .asp { background-color: #ffff00; }<br />
.csharpcode .html { color: #800000; }<br />
.csharpcode .attr { color: #ff0000; }<br />
.csharpcode .alt<br />
{<br />
	background-color: #f4f4f4;<br />
	width: 100%;<br />
	margin: 0em;<br />
}<br />
.csharpcode .lnum { color: #606060; }<br />
--></style>
<p>Firstly, these classes wouldn’t follow OCP principle, they would need to be modified if the system started to handle extra figures. These classes would use some code structure like if/else, switch/case, checking the object’s type (cast operation) or a combination of them, to perform different actions. The class would have to be modified to add a new scenario for the new figure, and depending on the quality of its test suite, a range from none to all tests would break.</p>
<p>Secondly, if they were different classes performing the system actions, it may be necessary to copy/paste these actions between them, or establishing new and complex connections that aren’t really necessary, just for the sake of reusing code.</p>
<p>Finally, they may be unexpected errors and behaviours if the code base were complex enough as to be likely to loose all the places where these patches were necessary.</p>
<p>None of these problems would raise on a design where the peculiarities and differences of this family of concepts were represented through an abstraction and “hidden” implementations.</p>
<h3>Enums considered harmful?</h3>
<p>I would like to wrap up this post talking about enums, which have a clear relation with some of the practices that we shouldn’t follow. Enums are just as good as any other structure or feature that a language offers, if used wisely.</p>
<p>For example, if we have a concept that is as simple that we don’t need to perform any functionality or operation based on it, then enums are a good solution, because they enforce some constraints in the choices to represent the concept, while you keep it reasonable simple. For instance, if we want to collect the gender of our users, but we won’t perform any action based on it, using an enum would make more sense than using a simple string; with enums we wouldn’t need to validate the data because we would knew that only one of the defined values would be present.</p>
<p>However, if eventually we expect to start taking actions or decisions based on the enum values, then we should consider a proper class hierarchy. Otherwise we would end up with more if/else or switch/cases where, based on the enum value, we would perform different actions.</p>
<p>We should avoid this scenario and, instead, codify abstractions and implementations for the different pieces of our system where we would do something different based on the enum. And, linking back to the very beginning of this post, we would have one single switch where we would decide which specific implementation of our abstraction we should use, while the rest of the system is kept ignorant of the specifics of each implementation.</p>
<h3>Conclusion</h3>
<p>Be careful when you start writing if/else, switch/case and casting statements. Think twice if that functionality shouldn’t be done by a class hierarchy where you can hide the specific details of each scenario.</p>
<p>Use enums as an early indicator of these wrong practices. If you represent a concept that may have its own actions or functionality, you will probably end up writing nasty code that will be hard to maintain and extend.</p>
