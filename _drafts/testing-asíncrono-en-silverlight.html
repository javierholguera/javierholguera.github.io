---
layout: post
title: Testing asíncrono en Silverlight
date: 
type: post
published: false
status: draft
categories: []
tags: []
meta:
  _edit_last: '11'
author:
  login: admin
  email: javier.holguera@gmail.com
  display_name: admin
  first_name: ''
  last_name: ''
---
<p>Últimamente me está tocando pelearme con una aplicación Silverlight y todo lo que ello conlleva; esto, por supuesto, incluye su testeo, puesto que ninguna aplicación seria debería salir a producción sin tener una buena batería de tests asociada.</p>
<p>En mi caso, tengo una DLL Silverlight encargada de realizar la comunicación con unos servicios WCF. Cada una de las clases de esta DLL representa un “wrapper” sobre el proxy correspondiente, generado por Visual Studio. Cualquiera que tenga algo de experiencia en el tandem WCF-Silverlight, sabrá que las llamadas deben, por fuerza (más bien por imperativo de Silverlight), realizarse de forma asíncrona.</p>
<p>Me voy a quitar la careta de “buen desarrollador” y voy a reconocer que esta buena práctica, aunque posiblemente sea un “must”, me resulta engorrosa e incómoda. En cualquier caso, nobleza obliga y no queda más remedio que programar así. Lo malo es que a la hora de testear, esto puede ponerse complicado. Por suerte, acude a nuestro rescate el reciente framework de testeo de Silverlight que los chicos de Microsoft, en la figura de Jeff Wilcox, han tenido a bien liberar.</p>
<p>Seré sincero por segunda vez en tres párrafos: me parece que este framework está bastante verde. No hay integración con el resto del entorno de testing de Visual Studio (olvídate del Test View), los test se lanzan sobre una app Silverlight ad-hoc cuya única finalidad es mostrar los resultados, no hay accessors (y esto tiene difícil solución, pues al parecer Silverlight impide el acceso a miembros privados por Reflection), la documentación es poca, etc. No digo que sepa cómo hacerlo mejor, pero lo que hay ahora mismo me parece muy limitado comparado con lo que tenemos en testing de CLR.</p>
<p>Convenientemente dado el palo nuestro de cada post, he de reconocer que me ha agradado gratamente la forma en que resuelven el problema del testeo de un método asíncrono, como sería la llamada a un proxy y la posterior recepción del resultado de esta llamada. Ejemplo práctico:</p>
<ol>
<li>Invoco a un método GetXXX en mi DLL Silverlight, que a su vez se encarga de llamar a proxy.GetXXX </li>
<li>El método retorna inmediatamente, cosas de la asincronía, sin esperar a recibir el resultado. </li>
<li>
<p>Si estuviera en un test “normal”, mi test terminaría y yo aún no habría probado lo importante, la recepción y tratamiento del resultado de esta invocación. </p>
</li>
<li>Para los que en este punto digan en alto “AutoResetEvent” o el nombre de cualquier otro objeto de sincronización, respuesta incorrecta. En Silverlight, y los tests para Silverlight son a su vez métodos Silverlight también, si bloqueamos el hilo a la espera de la recepción de la respuesta, ésta no llegará a producirse nunca.</li>
</ol>
<p>&#160;</p>
<p>¿Cómo resuelve este problema el nuevo framework de testing de Silverlight? Con el concepto de “encolamiento” de trabajo. Básicamente nuestros tests se van a componer del código “clásico”, el que debe ejecutarse antes de que se cierre el método del test, más una serie de tareas que se encolan con la idea de ejecutarlas una vez se ha completado el método del test. Por ejemplo, en el caso descrito anterior, un test cualquiera con este concepto tendría la siguiente estructura:</p>
<ol>
<li>Defino el método asíncrono a invocar y el resto del código que quiero ejecutar inmediatamente</li>
<li>Defino las tareas que habrán de ejecutarse tan pronto se cierre el método del test. Básicamente, en la mayoría de casos, esto incluirá el conjunto de aserciones que esperamos se cumplan tras terminarse la invocación asíncrona</li>
<li>Cierro el método.</li>
</ol>
<p>Le tomo prestado a Jeff Wilcox un gráfico muy explícito sobre cómo funciona este testing asíncrono:</p>
<p><a href="http://javi.azurewebsites.net/wp-content/uploads/2010/07/WorkItemExample2.png"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="WorkItemExample2" border="0" alt="WorkItemExample2" src="{{ site.baseurl }}/assets/WorkItemExample2_thumb.png" width="430" height="321" /></a> </p>
<p>Como bien podemos ver en ese gráfico, la forma en que el framework de testing sabrá que, por fin, hemos terminado de ejecutar todas las tareas de que se compone nuestro test y que, por tanto, puede publicar el resultado, es mediante la invocación del método TestComplete().</p>
<p>&#160;</p>
<p>Y como se suele decir que un ejemplo vale más que mil palabras, hé aquí un test asíncrono:</p>
