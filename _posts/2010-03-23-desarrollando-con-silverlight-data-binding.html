---
layout: post
title: 'Desarrollando con Silverlight: Data binding'
date: 2010-03-23 23:54:20.000000000 +00:00
type: post
published: true
status: publish
categories:
- Silverlight
tags:
- custom controls
- data binding
- enlaces
- Silverlight
meta:
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1445537948;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:121;}i:1;a:1:{s:2:"id";i:111;}i:2;a:1:{s:2:"id";i:53;}}}}
author:
  login: admin
  email: javier.holguera@gmail.com
  display_name: admin
  first_name: ''
  last_name: ''
---
<p>Unos cuantos apuntes rápidos sobre Silverlight y Data binding, más a título personal (para no olvidarme de estos recursos y estas conclusiones) que con ánimo de salvarle la vida a nadie (no he conseguido ni arreglar mis propios problemas…).</p>
<p>En primer lugar, <a href="http://msdn.microsoft.com/en-us/library/cc278072(VS.95).aspx">este artículo en MSDN sobre Data Binding</a>. Algunas de las conclusiones que he podido sacar son:</p>
<ul>
<li>Usar la propiedad DataContext de los objetos para enlazarlos con objetos del CLR (sources). Permite herencia hacia abajo y también se hereda de los controles padre, por lo que si no queremos que un objeto tenga el mismo valor que su padre, habrá que sobreescribirla.</li>
<li>La propiedad ElementName nos vale para enlazar a otros controles XAML en lugar de a un objeto del CLR</li>
<li>La propiedad RelativeSource para servir para enlazar a elementos en un Control Template.</li>
<li>Es necesario implementar INotifyPropertyChanged en los objetos que queramos que funcionen como sources, si queremos tener TwoWay en el binding. Si lo queremos hacer con una colección, tendrá que implementar INotifyCollectionChanged. En cualquier caso, la colección ObservableCollection&lt;T&gt; ya lo hace, con lo que es una buena opción para no reinventar la rueda.</li>
<li>Si queremos que nos aparezcan esos cartelitos rojos tan chulos con los mensajes de error que hayamos definido (aquí entra en juego los Data Annotations, estupendos para poder hacer validaciones más finas), tenemos que marcar a true las propiedades ValidatesOnException y NotifyOnValidationError del binding, en el fragmento XAML.</li>
</ul>
<p>El punto en que me encuentro ahora es que tengo una validación correcta, pero al estar usando un control con su propio manejo de los estados, no es capaz de mostrar los errores (más bien, imagino que pasar a un estado “erróneo” que, por defecto en SL, tendrá asociada una transición que hace aparecer la caja con el error y demás artificios visuales).</p>
<p>Enlaces sobre los que trabajar:</p>
<ul>
<li><a href="http://blogs.silverlight.net/blogs/jesseliberty/archive/2008/10/09/custom-controls-the-denouement.aspx">Jesse Liberty hablando de controles custom</a> y cómo definir transiciones con Visual State Manager, entre otros puntos.</li>
<li><a href="http://blogs.silverlight.net/blogs/jesseliberty/archive/2009/07/18/what-s-new-in-silverlight-3-validation.aspx">Jesse Liberty hablando sobre la validación en controles SL</a>.</li>
</ul>
<p>Tan pronto resuelva el problema, publicaré puntualmente.</p>
