---
layout: post
title: 'Code Coverage (I): Activación'
date: 2010-01-14 10:25:05.000000000 +00:00
type: post
published: true
status: publish
categories:
- Visual Studio 2008
tags:
- '2008'
- code
- coverage
- studio
- visual
meta:
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1449308045;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:23;}i:1;a:1:{s:2:"id";i:291;}i:2;a:1:{s:2:"id";i:123;}}}}
author:
  login: admin
  email: javier.holguera@gmail.com
  display_name: admin
  first_name: ''
  last_name: ''
---
<p>Voy a decirlo aquí en alto y con vergüenza: hasta esta semana, no había usado nunca el Code Coverage. Y como ocurre con todas las buenas herramientas, ahora pienso: “¿cómo he podido estar sin esto hasta ahora?”.</p>
<p>Empezar a usarlo es sencillo, aunque tiene una pequeña peculiaridad: sólo funciona cuando los tests se ejecutan, no si se depurar. ¿Qué quiere decir esto? Que a la hora de seleccionar el conjunto de tests que queramos lanzar, deberemos utilizar la opción “Run Selection” en lugar de “Debug Selection”, en la ventana de “Test View”.</p>
<p><a href="{{ site.baseurl }}/assets/uploads/2010/01/TestViewWindow.png"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="TestViewWindow" src="{{ site.baseurl }}/assets/TestViewWindow_thumb.png" border="0" alt="TestViewWindow" width="229" height="315" /></a></p>
<p>Como ya sabemos, el problema de esto es que cualquier punto de depuración que tengamos en el código no va a ejecutarse, pero parece un mal menor comparado con las posibilidades que tiene Code Coverage. Además, uno de los principios de testeo unitario es precisamente evitar la necesidad de depurar el código, así que no hay de qué quejarse.</p>
<p>Para poder ver la pestaña que muestra los resultados de cobertura de código existen dos posibilidades: pulsar el último de los botones que parecen en la ventana de “Test Results” o bien acceder a la opción de menú “Test – Windows – Code Coverage Results”.</p>
<p>Sin embargo, de poco nos servirá esto si no activamos previamente el Code Coverage para que se calculen sus resultados. Esto se configura en el fichero .testrunconfig que existe en la carpeta “Solution Items”.</p>
<p><a href="{{ site.baseurl }}/assets/uploads/2010/01/TestRunConfig.png"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="TestRunConfig" src="{{ site.baseurl }}/assets/TestRunConfig_thumb.png" border="0" alt="TestRunConfig" width="367" height="263" /></a></p>
<p>Una vez abierto, hay pulsar en la opción de “Code Coverage” y seleccionar los assemblies sobre los que vamos a calcular la cobertura de código. Este punto es más importante de lo que podría pensarse, puesto que lo normal será tener dos versiones para cada uno: la versión de Debug y la versión de Release (podemos tener más si existen más configuraciones del proyecto). La clave es que no podemos elegir las dos a la vez, por lo que seleccionemos la que seleccionemos, tendrá que estar “sincronizada” con la configuración actual del proyecto. De lo contrario, tendremos un problema: la cobertura se calculará sobre un assembly que no tiene porqué estar actualizado con los últimos cambios que hemos hecho en el código.</p>
<p>Un ejemplo: digamos que hemos elegido la versión de Debug del assembly, pero tenemos configurado el proyecto en modo Release. Tenemos un 100% de cobertura de código, pero introducimos nuevas líneas en un método y compilamos (en Release). El assembly de Debug, sobre el que se va a pasar la cobertura, no ha cambiado, por lo que nos seguirá marcando 100% de cobertura aún cuando sabemos que no tenemos tests para el código que acabamos de añadir. Puede ser todo un problema, ¿verdad?</p>
<p>Por hoy es suficiente. Otro día, cómo interpretar los resultados y el coloreado del código.</p>
